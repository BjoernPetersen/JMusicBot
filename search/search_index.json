{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 JMusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music.","title":"Overview"},{"location":"#overview","text":"JMusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music.","title":"Overview"},{"location":"plugins/","text":"Plugin types \u00b6 JMusicBot allows you to write a variety of plugins. There are four specific base interfaces, which all implement the same basic Plugin interface: GenericPlugin PlaybackFactory Provider Suggester PlaybackFactory \u00b6 A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played. Playback \u00b6 A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot). Provider \u00b6 Providers are the integral part to integrating music providers into JMusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically declares a PlaybackFactory dependency, which it delegates to whenever the Playback for a song is actually requested via the getPlaybackSupplier() method.","title":"Plugin types"},{"location":"plugins/#plugin-types","text":"JMusicBot allows you to write a variety of plugins. There are four specific base interfaces, which all implement the same basic Plugin interface: GenericPlugin PlaybackFactory Provider Suggester","title":"Plugin types"},{"location":"plugins/#playbackfactory","text":"A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played.","title":"PlaybackFactory"},{"location":"plugins/#playback","text":"A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot).","title":"Playback"},{"location":"plugins/#provider","text":"Providers are the integral part to integrating music providers into JMusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically declares a PlaybackFactory dependency, which it delegates to whenever the Playback for a song is actually requested via the getPlaybackSupplier() method.","title":"Provider"},{"location":"plugins/declaration/","text":"Declaration \u00b6 Bases \u00b6 A plugin may implement several base interfaces, which are annotated either by @Base , @ActiveBase or @IdBase . Superclasses which are not annotated with either of those are ignored. @Base \u00b6 Use this to annotate a base class or interface which other plugins might depend on. It is recommended to create a base interface or class for your plugin, even if you don't plan on creating multiple implementations yourself. @IdBase \u00b6 If your plugin implements Provider or Suggester , your plugin will be looked up by its ID. The ID is derived from its most specific base, which is identified by the @IdBase annotation. If, for some reason, you absolutely don't want to create a base interface, you may also annotate your implementation with @IdBase directly. A plugin must not have more than one ID base. @ActiveBase \u00b6 This annotation is reserved for predefined base interfaces ( Provider and Suggester ). It marks bases which are actively used by the bot and may have multiple active implementations. Plugins implementing an active base must also have an ID base. Examples \u00b6 Provider \u00b6 A Provider for Spotify songs may have a base interface SpotifyProvider , which is declared as an @IdBase . All implementations of the SpotifyProvider base must use the same song IDs to be compatible. @IdBase interface SpotifyProvider : Provider class SpotifyProviderImpl : SpotifyProvider PlaybackFactory \u00b6 The PlaybackFactory interface does not have value in itself, so instead, just specializations of the PlaybackFactory interface are annotated with @Base , for example Mp3PlaybackFactory or YouTubePlaybackFactory . An implementation using VLC to play a variety of file formats may look like this: interface VlcPlaybackFactory : Mp3PlaybackFactory, AacPlaybackFactory, FlacPlaybackFactory class VlcPlaybackFactoryImpl : VlcPlaybackFactory Note that the used playback factories are predefined in the core library. An implementation for Spotify songs may look like this: @Base interface SpotifyPlaybackFactory : PlaybackFactory { fun getPlayback(spotifySongId: String): Playback } class SpotifyProviderImpl : SpotifyPlaybackFactory Note that in this case, the base interface declares the crucial getPlayback(...) method itself. Without it, a PlaybackFactory would not be not useful at all. Service \u00b6 In order for the bot to find your plugin, you have to create a file with the fully qualified name of the implemented specific base interface (e.g. net.bjoernpetersen.musicbot.spi.plugin.Provider ) in the META-INF/services directory. The file should contain all your implementations of the base interface, each on its own line.","title":"Declaration"},{"location":"plugins/declaration/#declaration","text":"","title":"Declaration"},{"location":"plugins/declaration/#bases","text":"A plugin may implement several base interfaces, which are annotated either by @Base , @ActiveBase or @IdBase . Superclasses which are not annotated with either of those are ignored.","title":"Bases"},{"location":"plugins/declaration/#base","text":"Use this to annotate a base class or interface which other plugins might depend on. It is recommended to create a base interface or class for your plugin, even if you don't plan on creating multiple implementations yourself.","title":"@Base"},{"location":"plugins/declaration/#idbase","text":"If your plugin implements Provider or Suggester , your plugin will be looked up by its ID. The ID is derived from its most specific base, which is identified by the @IdBase annotation. If, for some reason, you absolutely don't want to create a base interface, you may also annotate your implementation with @IdBase directly. A plugin must not have more than one ID base.","title":"@IdBase"},{"location":"plugins/declaration/#activebase","text":"This annotation is reserved for predefined base interfaces ( Provider and Suggester ). It marks bases which are actively used by the bot and may have multiple active implementations. Plugins implementing an active base must also have an ID base.","title":"@ActiveBase"},{"location":"plugins/declaration/#examples","text":"","title":"Examples"},{"location":"plugins/declaration/#provider","text":"A Provider for Spotify songs may have a base interface SpotifyProvider , which is declared as an @IdBase . All implementations of the SpotifyProvider base must use the same song IDs to be compatible. @IdBase interface SpotifyProvider : Provider class SpotifyProviderImpl : SpotifyProvider","title":"Provider"},{"location":"plugins/declaration/#playbackfactory","text":"The PlaybackFactory interface does not have value in itself, so instead, just specializations of the PlaybackFactory interface are annotated with @Base , for example Mp3PlaybackFactory or YouTubePlaybackFactory . An implementation using VLC to play a variety of file formats may look like this: interface VlcPlaybackFactory : Mp3PlaybackFactory, AacPlaybackFactory, FlacPlaybackFactory class VlcPlaybackFactoryImpl : VlcPlaybackFactory Note that the used playback factories are predefined in the core library. An implementation for Spotify songs may look like this: @Base interface SpotifyPlaybackFactory : PlaybackFactory { fun getPlayback(spotifySongId: String): Playback } class SpotifyProviderImpl : SpotifyPlaybackFactory Note that in this case, the base interface declares the crucial getPlayback(...) method itself. Without it, a PlaybackFactory would not be not useful at all.","title":"PlaybackFactory"},{"location":"plugins/declaration/#service","text":"In order for the bot to find your plugin, you have to create a file with the fully qualified name of the implemented specific base interface (e.g. net.bjoernpetersen.musicbot.spi.plugin.Provider ) in the META-INF/services directory. The file should contain all your implementations of the base interface, each on its own line.","title":"Service"},{"location":"plugins/lifecycle/","text":"Lifecycle \u00b6 Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation. Creation \u00b6 Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, it's dependencies are statically evaluated and the only property that will be accessed is its name property. The end user chooses which plugins to actually activate and how dependencies are satisfied. Configuration \u00b6 The plugin's dependencies are injected and its configuration methods are called: createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> createStateEntries(Config) The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities. Initialization \u00b6 The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed. Destruction \u00b6 The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Lifecycle"},{"location":"plugins/lifecycle/#lifecycle","text":"Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation.","title":"Lifecycle"},{"location":"plugins/lifecycle/#creation","text":"Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, it's dependencies are statically evaluated and the only property that will be accessed is its name property. The end user chooses which plugins to actually activate and how dependencies are satisfied.","title":"Creation"},{"location":"plugins/lifecycle/#configuration","text":"The plugin's dependencies are injected and its configuration methods are called: createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> createStateEntries(Config) The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities.","title":"Configuration"},{"location":"plugins/lifecycle/#initialization","text":"The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed.","title":"Initialization"},{"location":"plugins/lifecycle/#destruction","text":"The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Destruction"},{"location":"plugins/resources/","text":"Resources \u00b6 Provider plugins may allocate resources when a song is loaded via the Provider.loadSong() method. Such a resource could be reusable (e.g. a downloaded file) or single-use (e.g. a data stream). Whenever the Core determines that the resource for a song might be needed soon, it will check whether a valid resource is cached for the song, and if not, call your loadSong() implementation. The resource might be discarded without ever being used, but before a resource is discarded, it is guaranteed that the Resource.free() method will be called. Examples \u00b6 No resources \u00b6 If you don't need to allocate any resources, you can simply return the NoResource singleton. Kotlin: override fun loadSong(song: Song): Resource = NoResource Java: @Override public Resource loadSong(Song song) { return NoResource.INSTANCE; } File resources \u00b6 A commonly used type of resource is a file resource. Let's say your provider needs to download an MP3-file before playing it. That MP3-file of course needs to be deleted at some point in the future, because storage space is typically finite. For that use case, the FileResource class is already included in the Core library. In this case your loadSong() and supplyPlayback() methods might look the following way: Kotlin: @Base interface MyPlaybackFactory : FilePlaybackFactory @IdBase class MyProvider : Provider { @Inject private lateinit var myPlaybackFactory: MyPlaybackFactory // ... override fun loadSong(song: Song): Resource { val file: File = downloadSong(song) return FileResource(file) } override fun supplyPlayback(song: Song, resource: Resource): Playback { val fileResource = resource as FileResource return myPlaybackFactory.createPlayback(fileResource.file) } } Java: // file MyPlaybackFactory.java @Base public interface MyPlaybackFactory extends FilePlaybackFactory {} // file MyProvider.java @IdBase public class MyProvider implements Provider { @Inject private myPlaybackFactory: MyPlaybackFactory // ... @Override public Resource loadSong(Song song) { File file = downloadSong(song); return new FileResource(file); } @Override public Playback supplyPlayback(song: Song, resource: Resource) { FileResource fileResource = (FileResource) resource return myPlaybackFactory.createPlayback(fileResource.getFile()) } }","title":"Resources"},{"location":"plugins/resources/#resources","text":"Provider plugins may allocate resources when a song is loaded via the Provider.loadSong() method. Such a resource could be reusable (e.g. a downloaded file) or single-use (e.g. a data stream). Whenever the Core determines that the resource for a song might be needed soon, it will check whether a valid resource is cached for the song, and if not, call your loadSong() implementation. The resource might be discarded without ever being used, but before a resource is discarded, it is guaranteed that the Resource.free() method will be called.","title":"Resources"},{"location":"plugins/resources/#examples","text":"","title":"Examples"},{"location":"plugins/resources/#no-resources","text":"If you don't need to allocate any resources, you can simply return the NoResource singleton. Kotlin: override fun loadSong(song: Song): Resource = NoResource Java: @Override public Resource loadSong(Song song) { return NoResource.INSTANCE; }","title":"No resources"},{"location":"plugins/resources/#file-resources","text":"A commonly used type of resource is a file resource. Let's say your provider needs to download an MP3-file before playing it. That MP3-file of course needs to be deleted at some point in the future, because storage space is typically finite. For that use case, the FileResource class is already included in the Core library. In this case your loadSong() and supplyPlayback() methods might look the following way: Kotlin: @Base interface MyPlaybackFactory : FilePlaybackFactory @IdBase class MyProvider : Provider { @Inject private lateinit var myPlaybackFactory: MyPlaybackFactory // ... override fun loadSong(song: Song): Resource { val file: File = downloadSong(song) return FileResource(file) } override fun supplyPlayback(song: Song, resource: Resource): Playback { val fileResource = resource as FileResource return myPlaybackFactory.createPlayback(fileResource.file) } } Java: // file MyPlaybackFactory.java @Base public interface MyPlaybackFactory extends FilePlaybackFactory {} // file MyProvider.java @IdBase public class MyProvider implements Provider { @Inject private myPlaybackFactory: MyPlaybackFactory // ... @Override public Resource loadSong(Song song) { File file = downloadSong(song); return new FileResource(file); } @Override public Playback supplyPlayback(song: Song, resource: Resource) { FileResource fileResource = (FileResource) resource return myPlaybackFactory.createPlayback(fileResource.getFile()) } }","title":"File resources"}]}