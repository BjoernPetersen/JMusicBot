{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 MusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music. This site is still in an early stage and not comprehensive yet. Feel free to create a GitHub issue if you have questions or suggestions.","title":"Overview"},{"location":"#overview","text":"MusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music. This site is still in an early stage and not comprehensive yet. Feel free to create a GitHub issue if you have questions or suggestions.","title":"Overview"},{"location":"plugins/","text":"Plugin types \u00b6 JMusicBot allows you to write a variety of plugins. There are four specific service interfaces, which all extend the same basic Plugin interface: GenericPlugin PlaybackFactory Provider Suggester Also have a look at the declaration section for further instructions on how to implement a plugin. PlaybackFactory \u00b6 A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played or seek within a song. Playback \u00b6 A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot). Provider \u00b6 Providers are the most integral part to integrating music providers into the MusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically depends on a PlaybackFactory , which it delegates to whenever the Playback for a song is actually requested via the supplyPlayback() method. Suggester \u00b6 Suggesters provide song suggestions based on some arbitrary algorithm. For example, they could provide shuffled MP3s from the local disk, or songs from a Spotify playlist. A Suggester typically depends on a Provider to actually provide the songs it is suggesting.","title":"Plugin types"},{"location":"plugins/#plugin-types","text":"JMusicBot allows you to write a variety of plugins. There are four specific service interfaces, which all extend the same basic Plugin interface: GenericPlugin PlaybackFactory Provider Suggester Also have a look at the declaration section for further instructions on how to implement a plugin.","title":"Plugin types"},{"location":"plugins/#playbackfactory","text":"A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played or seek within a song.","title":"PlaybackFactory"},{"location":"plugins/#playback","text":"A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot).","title":"Playback"},{"location":"plugins/#provider","text":"Providers are the most integral part to integrating music providers into the MusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically depends on a PlaybackFactory , which it delegates to whenever the Playback for a song is actually requested via the supplyPlayback() method.","title":"Provider"},{"location":"plugins/#suggester","text":"Suggesters provide song suggestions based on some arbitrary algorithm. For example, they could provide shuffled MP3s from the local disk, or songs from a Spotify playlist. A Suggester typically depends on a Provider to actually provide the songs it is suggesting.","title":"Suggester"},{"location":"plugins/declaration/","text":"Declaration \u00b6 Bases \u00b6 A plugin may implement several base interfaces, which are annotated by @Base , @ActiveBase or @IdBase . Superclasses which are not annotated with either of those are ignored. @Base \u00b6 Use this to annotate a base class or interface which other plugins might depend on. It is recommended to create a base interface or class for your plugin, even if you don't plan on creating multiple implementations yourself. @ActiveBase \u00b6 This annotation marks a base which is either actively used by the bot (like Provider and Suggester ), or actively provides a feature and should be enabled even if no other active plugin depends on it. Plugins implementing an active base must also have an ID base. @IdBase \u00b6 If your plugin implements an active base (such as Provider or Suggester ), it needs a base that identifies it. There will always be only one enabled plugin per ID base. For example, a provider of Spotify songs should implement a base interface SpotifyProvider annotated with @IdBase . Songs that implementation provides would not have a reference to the implementation itself, but to its ID, SpotifyProvider . If someone else comes along now and creates an alternative implementation of that ID base, songs created by the first implementation could still be used even though the implementation changed. If, for some reason, you absolutely don't want to create a separate base interface, you may also annotate your implementation with @IdBase directly. A plugin must not have more than one ID base. Examples \u00b6 Provider \u00b6 A Provider for Spotify songs may have a base interface SpotifyProvider , which is declared as an @IdBase . All implementations of the SpotifyProvider base must use the same song ID format to be compatible. @IdBase(\"Spotify\") interface SpotifyProvider : Provider class SpotifyProviderImpl : SpotifyProvider PlaybackFactory \u00b6 The PlaybackFactory interface does not have value in itself, so instead, just specializations of the PlaybackFactory interface are annotated with @Base , for example Mp3PlaybackFactory or YouTubePlaybackFactory . An implementation using VLC to play a variety of file formats may look like this: interface VlcPlaybackFactory : Mp3PlaybackFactory, AacPlaybackFactory, FlacPlaybackFactory class VlcPlaybackFactoryImpl : VlcPlaybackFactory Note that the base interfaces used here are predefined in the core library. An implementation for Spotify songs may look like this: @Base interface SpotifyPlaybackFactory : PlaybackFactory { fun getPlayback(spotifySongId: String): Playback } class SpotifyPlaybackFactoryImpl : SpotifyPlaybackFactory Note that in this case, the base interface declares the crucial getPlayback(...) method itself. Without it, a PlaybackFactory would not be not useful at all. Service \u00b6 In order for the bot to find your plugin, you have to create a file with the fully qualified name of the implemented plugin interface (e.g. net.bjoernpetersen.musicbot.spi.plugin.Provider ) in the META-INF/services directory. The file should contain all your implementations of the base interface, each on its own line.","title":"Declaration"},{"location":"plugins/declaration/#declaration","text":"","title":"Declaration"},{"location":"plugins/declaration/#bases","text":"A plugin may implement several base interfaces, which are annotated by @Base , @ActiveBase or @IdBase . Superclasses which are not annotated with either of those are ignored.","title":"Bases"},{"location":"plugins/declaration/#base","text":"Use this to annotate a base class or interface which other plugins might depend on. It is recommended to create a base interface or class for your plugin, even if you don't plan on creating multiple implementations yourself.","title":"@Base"},{"location":"plugins/declaration/#activebase","text":"This annotation marks a base which is either actively used by the bot (like Provider and Suggester ), or actively provides a feature and should be enabled even if no other active plugin depends on it. Plugins implementing an active base must also have an ID base.","title":"@ActiveBase"},{"location":"plugins/declaration/#idbase","text":"If your plugin implements an active base (such as Provider or Suggester ), it needs a base that identifies it. There will always be only one enabled plugin per ID base. For example, a provider of Spotify songs should implement a base interface SpotifyProvider annotated with @IdBase . Songs that implementation provides would not have a reference to the implementation itself, but to its ID, SpotifyProvider . If someone else comes along now and creates an alternative implementation of that ID base, songs created by the first implementation could still be used even though the implementation changed. If, for some reason, you absolutely don't want to create a separate base interface, you may also annotate your implementation with @IdBase directly. A plugin must not have more than one ID base.","title":"@IdBase"},{"location":"plugins/declaration/#examples","text":"","title":"Examples"},{"location":"plugins/declaration/#provider","text":"A Provider for Spotify songs may have a base interface SpotifyProvider , which is declared as an @IdBase . All implementations of the SpotifyProvider base must use the same song ID format to be compatible. @IdBase(\"Spotify\") interface SpotifyProvider : Provider class SpotifyProviderImpl : SpotifyProvider","title":"Provider"},{"location":"plugins/declaration/#playbackfactory","text":"The PlaybackFactory interface does not have value in itself, so instead, just specializations of the PlaybackFactory interface are annotated with @Base , for example Mp3PlaybackFactory or YouTubePlaybackFactory . An implementation using VLC to play a variety of file formats may look like this: interface VlcPlaybackFactory : Mp3PlaybackFactory, AacPlaybackFactory, FlacPlaybackFactory class VlcPlaybackFactoryImpl : VlcPlaybackFactory Note that the base interfaces used here are predefined in the core library. An implementation for Spotify songs may look like this: @Base interface SpotifyPlaybackFactory : PlaybackFactory { fun getPlayback(spotifySongId: String): Playback } class SpotifyPlaybackFactoryImpl : SpotifyPlaybackFactory Note that in this case, the base interface declares the crucial getPlayback(...) method itself. Without it, a PlaybackFactory would not be not useful at all.","title":"PlaybackFactory"},{"location":"plugins/declaration/#service","text":"In order for the bot to find your plugin, you have to create a file with the fully qualified name of the implemented plugin interface (e.g. net.bjoernpetersen.musicbot.spi.plugin.Provider ) in the META-INF/services directory. The file should contain all your implementations of the base interface, each on its own line.","title":"Service"},{"location":"plugins/lifecycle/","text":"Lifecycle \u00b6 Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation. Creation \u00b6 Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, its dependencies are statically evaluated and the only properties that will be accessed are the name and description properties. The end user chooses which plugins to actually activate and how dependencies are satisfied before moving on to the next lifecycle phase. Configuration \u00b6 The plugin's dependencies are injected and its configuration methods are called: createStateEntries(Config) createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities. Initialization \u00b6 The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed. Destruction \u00b6 The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Lifecycle"},{"location":"plugins/lifecycle/#lifecycle","text":"Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation.","title":"Lifecycle"},{"location":"plugins/lifecycle/#creation","text":"Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, its dependencies are statically evaluated and the only properties that will be accessed are the name and description properties. The end user chooses which plugins to actually activate and how dependencies are satisfied before moving on to the next lifecycle phase.","title":"Creation"},{"location":"plugins/lifecycle/#configuration","text":"The plugin's dependencies are injected and its configuration methods are called: createStateEntries(Config) createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities.","title":"Configuration"},{"location":"plugins/lifecycle/#initialization","text":"The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed.","title":"Initialization"},{"location":"plugins/lifecycle/#destruction","text":"The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Destruction"},{"location":"plugins/resources/","text":"Resources \u00b6 Provider plugins may allocate resources when a song is loaded via the Provider.loadSong() method. Such a resource could be reusable (e.g. a downloaded file) or single-use (e.g. a data stream). Whenever the Core determines that the resource for a song might be needed soon, it will check whether a valid resource is cached for the song, and if not, call your loadSong() implementation. The resource might be discarded without ever being used, but before a resource is discarded, it is guaranteed that the Resource.free() method will be called. Examples \u00b6 No resources \u00b6 If you don't need to allocate any resources, you can simply return the NoResource singleton. Kotlin: override fun loadSong(song: Song): Resource = NoResource Java: @Override public Resource loadSong(Song song) { return NoResource.INSTANCE; } File resources \u00b6 A commonly used type of resource is a file resource. Let's say your provider needs to download an MP3-file before playing it. That MP3-file of course needs to be deleted at some point in the future, because storage space is typically finite. For that use case, the FileResource class is already included in the Core library. In this case your loadSong() and supplyPlayback() methods might look the following way: Kotlin: @Base interface MyPlaybackFactory : FilePlaybackFactory @IdBase class MyProvider : Provider { @Inject private lateinit var myPlaybackFactory: MyPlaybackFactory // ... override fun loadSong(song: Song): Resource { val file: File = downloadSong(song) return FileResource(file) } override fun supplyPlayback(song: Song, resource: Resource): Playback { val fileResource = resource as FileResource return myPlaybackFactory.createPlayback(fileResource.file) } } Java: // file MyPlaybackFactory.java @Base public interface MyPlaybackFactory extends FilePlaybackFactory {} // file MyProvider.java @IdBase public class MyProvider implements Provider { @Inject private myPlaybackFactory: MyPlaybackFactory // ... @Override public Resource loadSong(Song song) { File file = downloadSong(song); return new FileResource(file); } @Override public Playback supplyPlayback(song: Song, resource: Resource) { FileResource fileResource = (FileResource) resource return myPlaybackFactory.createPlayback(fileResource.getFile()) } }","title":"Resources"},{"location":"plugins/resources/#resources","text":"Provider plugins may allocate resources when a song is loaded via the Provider.loadSong() method. Such a resource could be reusable (e.g. a downloaded file) or single-use (e.g. a data stream). Whenever the Core determines that the resource for a song might be needed soon, it will check whether a valid resource is cached for the song, and if not, call your loadSong() implementation. The resource might be discarded without ever being used, but before a resource is discarded, it is guaranteed that the Resource.free() method will be called.","title":"Resources"},{"location":"plugins/resources/#examples","text":"","title":"Examples"},{"location":"plugins/resources/#no-resources","text":"If you don't need to allocate any resources, you can simply return the NoResource singleton. Kotlin: override fun loadSong(song: Song): Resource = NoResource Java: @Override public Resource loadSong(Song song) { return NoResource.INSTANCE; }","title":"No resources"},{"location":"plugins/resources/#file-resources","text":"A commonly used type of resource is a file resource. Let's say your provider needs to download an MP3-file before playing it. That MP3-file of course needs to be deleted at some point in the future, because storage space is typically finite. For that use case, the FileResource class is already included in the Core library. In this case your loadSong() and supplyPlayback() methods might look the following way: Kotlin: @Base interface MyPlaybackFactory : FilePlaybackFactory @IdBase class MyProvider : Provider { @Inject private lateinit var myPlaybackFactory: MyPlaybackFactory // ... override fun loadSong(song: Song): Resource { val file: File = downloadSong(song) return FileResource(file) } override fun supplyPlayback(song: Song, resource: Resource): Playback { val fileResource = resource as FileResource return myPlaybackFactory.createPlayback(fileResource.file) } } Java: // file MyPlaybackFactory.java @Base public interface MyPlaybackFactory extends FilePlaybackFactory {} // file MyProvider.java @IdBase public class MyProvider implements Provider { @Inject private myPlaybackFactory: MyPlaybackFactory // ... @Override public Resource loadSong(Song song) { File file = downloadSong(song); return new FileResource(file); } @Override public Playback supplyPlayback(song: Song, resource: Resource) { FileResource fileResource = (FileResource) resource return myPlaybackFactory.createPlayback(fileResource.getFile()) } }","title":"File resources"}]}