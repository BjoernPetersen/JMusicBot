{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 JMusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music.","title":"Overview"},{"location":"#overview","text":"JMusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music.","title":"Overview"},{"location":"plugins/","text":"Plugins \u00b6 JMusicBot allows you to write a variety of plugins. There are four base classes, which all implement the same basic Plugin contract: GenericPlugin PlaybackFactory Provider Suggester Lifecycle \u00b6 Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation. Creation \u00b6 Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, it's dependencies are statically evaluated and the only property that will be accessed is its name property. The end user chooses which plugins to actually activate and how dependencies are satisfied. Configuration \u00b6 The plugin's dependencies are injected and its configuration methods are called: createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> createStateEntries(Config) The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities. Initialization \u00b6 The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed. Destruction \u00b6 The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again. PlaybackFactory \u00b6 A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played. Playback \u00b6 A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot). Provider \u00b6 Providers are the integral part to integrating music providers into JMusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically declares a PlaybackFactory dependency, which it delegates to whenever the Playback for a song is actually requested via the getPlaybackSupplier() method.","title":"Plugins"},{"location":"plugins/#plugins","text":"JMusicBot allows you to write a variety of plugins. There are four base classes, which all implement the same basic Plugin contract: GenericPlugin PlaybackFactory Provider Suggester","title":"Plugins"},{"location":"plugins/#lifecycle","text":"Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation.","title":"Lifecycle"},{"location":"plugins/#creation","text":"Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, it's dependencies are statically evaluated and the only property that will be accessed is its name property. The end user chooses which plugins to actually activate and how dependencies are satisfied.","title":"Creation"},{"location":"plugins/#configuration","text":"The plugin's dependencies are injected and its configuration methods are called: createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> createStateEntries(Config) The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities.","title":"Configuration"},{"location":"plugins/#initialization","text":"The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed.","title":"Initialization"},{"location":"plugins/#destruction","text":"The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Destruction"},{"location":"plugins/#playbackfactory","text":"A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played.","title":"PlaybackFactory"},{"location":"plugins/#playback","text":"A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot).","title":"Playback"},{"location":"plugins/#provider","text":"Providers are the integral part to integrating music providers into JMusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically declares a PlaybackFactory dependency, which it delegates to whenever the Playback for a song is actually requested via the getPlaybackSupplier() method.","title":"Provider"}]}