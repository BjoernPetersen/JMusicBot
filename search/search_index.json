{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 MusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music. Note: This site is still in an early stage and not exhaustive yet. Feel free to create a GitHub issue if you have questions or suggestions. Why you should use this \u00b6 There are several alternatives that provide at least the some of this project's features, for example Spotify Connect, Google Cast or simply using Bluetooth. This section will list a few key features that make MusicBot superior to those alternatives. Multiple users \u00b6 Multiple users can connect to the bot with their own, personal devices and enqueue songs. This is not only more convenient than sharing one device, but also adds some accountability to the situation: You no longer have to worry about some half-wit skipping the Pi\u00f1a Colada Song you added to the queue or wonder who the hilarious dude that snuck Never Gonna Give You Up into the queue for the millionth time is. Multiple song providers \u00b6 You are not bound to a single provider like Spotify or Google Play Music. You can add songs from various different providers to the queue and they will be played without any disruption. With alternatives, you can only play songs from one provider at once. What often happens then is that somebody wants to listen to a song that's only available somewhere else (typically YouTube). Following is usually a short disruption, a series of YouTube songs/videos of decreasing quality and then silence, because nobody went back and resumed the previous playback. Independent from remote \u00b6 If the bot is running on a stationary device (PC, Laptop, Raspberry Pi), no one can run off with the bot and disrupt the music, as would be the case with simple Bluetooth streaming from a phone. Concept \u00b6 This library defines a common set of interfaces through which the different parts of the bot can communicate with each other. This includes base interfaces for plugins as well as various interfaces for server implementations. The core tries to be compatible with any operating system that supports Java. This especially includes Android, which only has (limited) Java 8 compatibility. Plugins are used for everything that's either OS dependent or too volatile to remain stable over a long time period. Most importantly this includes access to music provider APIs .","title":"Overview"},{"location":"#overview","text":"MusicBot is a library that allows you to create a collaborative music queue using songs from several providers like Spotify, YouTube or Google Play Music. Note: This site is still in an early stage and not exhaustive yet. Feel free to create a GitHub issue if you have questions or suggestions.","title":"Overview"},{"location":"#why-you-should-use-this","text":"There are several alternatives that provide at least the some of this project's features, for example Spotify Connect, Google Cast or simply using Bluetooth. This section will list a few key features that make MusicBot superior to those alternatives.","title":"Why you should use this"},{"location":"#multiple-users","text":"Multiple users can connect to the bot with their own, personal devices and enqueue songs. This is not only more convenient than sharing one device, but also adds some accountability to the situation: You no longer have to worry about some half-wit skipping the Pi\u00f1a Colada Song you added to the queue or wonder who the hilarious dude that snuck Never Gonna Give You Up into the queue for the millionth time is.","title":"Multiple users"},{"location":"#multiple-song-providers","text":"You are not bound to a single provider like Spotify or Google Play Music. You can add songs from various different providers to the queue and they will be played without any disruption. With alternatives, you can only play songs from one provider at once. What often happens then is that somebody wants to listen to a song that's only available somewhere else (typically YouTube). Following is usually a short disruption, a series of YouTube songs/videos of decreasing quality and then silence, because nobody went back and resumed the previous playback.","title":"Multiple song providers"},{"location":"#independent-from-remote","text":"If the bot is running on a stationary device (PC, Laptop, Raspberry Pi), no one can run off with the bot and disrupt the music, as would be the case with simple Bluetooth streaming from a phone.","title":"Independent from remote"},{"location":"#concept","text":"This library defines a common set of interfaces through which the different parts of the bot can communicate with each other. This includes base interfaces for plugins as well as various interfaces for server implementations. The core tries to be compatible with any operating system that supports Java. This especially includes Android, which only has (limited) Java 8 compatibility. Plugins are used for everything that's either OS dependent or too volatile to remain stable over a long time period. Most importantly this includes access to music provider APIs .","title":"Concept"},{"location":"implementations/","text":"Overview \u00b6 There are two implementations available, so you shouldn't need to create a new one: MusicBot-desktop for desktop systems Qbert for Android What you need to supply \u00b6 BrowserOpener Broadcaster ConfigStorageAdapter FileStorage ImageLoader SongPlayedNotifier API server","title":"Overview"},{"location":"implementations/#overview","text":"There are two implementations available, so you shouldn't need to create a new one: MusicBot-desktop for desktop systems Qbert for Android","title":"Overview"},{"location":"implementations/#what-you-need-to-supply","text":"BrowserOpener Broadcaster ConfigStorageAdapter FileStorage ImageLoader SongPlayedNotifier API server","title":"What you need to supply"},{"location":"implementations/BrowserOpener/","text":"BrowserOpener \u00b6 Needing to open a browser is a common occurrence for plugins (OAuth) and this interface provides an easy way to do it in a system independent way.","title":"BrowserOpener"},{"location":"implementations/BrowserOpener/#browseropener","text":"Needing to open a browser is a common occurrence for plugins (OAuth) and this interface provides an easy way to do it in a system independent way.","title":"BrowserOpener"},{"location":"implementations/ConfigStorageAdapter/","text":"Config storage \u00b6 The MusicBot config is a simple mapping from String keys to String values, but there are many choices when it comes to storing it. The implementation is responsible for providing one or more adapters for this job. The easiest implementation would just store the mapping in a config file ( JSON / YAML / Properties ),but more complex solutions are of course possible. The implementation may choose to encrypt the values or store them on a remote server.","title":"Config storage"},{"location":"implementations/ConfigStorageAdapter/#config-storage","text":"The MusicBot config is a simple mapping from String keys to String values, but there are many choices when it comes to storing it. The implementation is responsible for providing one or more adapters for this job. The easiest implementation would just store the mapping in a config file ( JSON / YAML / Properties ),but more complex solutions are of course possible. The implementation may choose to encrypt the values or store them on a remote server.","title":"Config storage"},{"location":"implementations/api/","text":"API \u00b6 Perhaps the most important part of an implementation is serving the REST-API defined in the MusicBot-API project.","title":"API"},{"location":"implementations/api/#api","text":"Perhaps the most important part of an implementation is serving the REST-API defined in the MusicBot-API project.","title":"API"},{"location":"plugins/","text":"Overview \u00b6 MusicBot allows you to write a variety of plugins. There are four specific service interfaces, which all extend the same basic Plugin interface: GenericPlugin PlaybackFactory Provider Suggester Also have a look at the declaration section for further instructions on how to implement a plugin. PlaybackFactory \u00b6 A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played or seek within a song. Playback \u00b6 A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot). Provider \u00b6 Providers are the most integral part to integrating music providers into the MusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically depends on a PlaybackFactory , which it delegates to whenever the Playback for a song is actually requested via the supplyPlayback() method. Suggester \u00b6 Suggesters provide song suggestions based on some arbitrary algorithm. For example, they could provide shuffled MP3s from the local disk, or songs from a Spotify playlist. A Suggester typically depends on a Provider to actually provide the songs it is suggesting.","title":"Overview"},{"location":"plugins/#overview","text":"MusicBot allows you to write a variety of plugins. There are four specific service interfaces, which all extend the same basic Plugin interface: GenericPlugin PlaybackFactory Provider Suggester Also have a look at the declaration section for further instructions on how to implement a plugin.","title":"Overview"},{"location":"plugins/#playbackfactory","text":"A PlaybackFactory provides a way to actually play a specific kind of song, for example MP3 files or YouTube videos. A few restrictions are imposed on Playback factories: It must be possible to pause and resume playback It must be possible to abort playback prematurely The end of a song must be automatically detected and reported to the bot Note that it is not a requirement to keep track of the duration a song has played or seek within a song.","title":"PlaybackFactory"},{"location":"plugins/#playback","text":"A PlaybackFactory creates a new Playback object for every song it should play. The Playback object is used to play a song exactly once. To implement Playback , you basically only need to implement two methods: play() and pause() . In addition to that, there is a waitForFinish() method that is supposed to block any callers until the song has finished playing. If you choose to extend the AbstractPlayback interface (recommended) you only don't have to implement the method, but only have to call the markDone() method once the song has finished. While this design has some limitations for the bot, it allows you to create implementations for a variety of services. For example, it wouldn't be possible to play Spotify songs if the only possibility were to directly stream songs, because Spotify doesn't allow that. Instead, the Spotify plugin simply controls the playback of an official Spotify client (which typically runs on the same machine as the bot).","title":"Playback"},{"location":"plugins/#provider","text":"Providers are the most integral part to integrating music providers into the MusicBot. They provide access to the songs of a specific source (Spotify, local hard disk, YouTube, etc.) by offering a search by query and a lookup by song ID. A provider also typically depends on a PlaybackFactory , which it delegates to whenever the Playback for a song is actually requested via the supplyPlayback() method.","title":"Provider"},{"location":"plugins/#suggester","text":"Suggesters provide song suggestions based on some arbitrary algorithm. For example, they could provide shuffled MP3s from the local disk, or songs from a Spotify playlist. A Suggester typically depends on a Provider to actually provide the songs it is suggesting.","title":"Suggester"},{"location":"plugins/declaration/","text":"Declaration \u00b6 Bases \u00b6 A plugin may implement several base interfaces, which are annotated by @Base , @ActiveBase or @IdBase . Superclasses which are not annotated with either of those are ignored. @Base \u00b6 Use this to annotate a base class or interface which other plugins might depend on. It is recommended to create a base interface or class for your plugin, even if you don't plan on creating multiple implementations yourself. @ActiveBase \u00b6 This annotation marks a base which is either actively used by the bot (like Provider and Suggester ), or actively provides a feature and should be enabled even if no other active plugin depends on it. Plugins implementing an active base must also have an ID base. @IdBase \u00b6 If your plugin implements an active base (such as Provider or Suggester ), it needs a base that identifies it. There will always be only one enabled plugin per ID base. For example, a provider of Spotify songs should implement a base interface SpotifyProvider annotated with @IdBase . Songs that implementation provides would not have a reference to the implementation itself, but to its ID, SpotifyProvider . If someone else comes along now and creates an alternative implementation of that ID base, songs created by the first implementation could still be used even though the implementation changed. If, for some reason, you absolutely don't want to create a separate base interface, you may also annotate your implementation with @IdBase directly. A plugin must not have more than one ID base. Examples \u00b6 Provider \u00b6 A Provider for Spotify songs may have a base interface SpotifyProvider , which is declared as an @IdBase . All implementations of the SpotifyProvider base must use the same song ID format to be compatible. @IdBase(\"Spotify\") interface SpotifyProvider : Provider class SpotifyProviderImpl : SpotifyProvider PlaybackFactory \u00b6 The PlaybackFactory interface does not have value in itself, so instead, just specializations of the PlaybackFactory interface are annotated with @Base , for example Mp3PlaybackFactory or YouTubePlaybackFactory . An implementation using VLC to play a variety of file formats may look like this: interface VlcPlaybackFactory : Mp3PlaybackFactory, AacPlaybackFactory, FlacPlaybackFactory class VlcPlaybackFactoryImpl : VlcPlaybackFactory Note that the base interfaces used here are predefined in the core library. An implementation for Spotify songs may look like this: @Base interface SpotifyPlaybackFactory : PlaybackFactory { fun getPlayback(spotifySongId: String): Playback } class SpotifyPlaybackFactoryImpl : SpotifyPlaybackFactory Note that in this case, the base interface declares the crucial getPlayback(...) method itself. Without it, a PlaybackFactory would not be not useful at all. Service \u00b6 In order for the bot to find your plugin, you have to create a file with the fully qualified name of the implemented plugin interface (e.g. net.bjoernpetersen.musicbot.spi.plugin.Provider ) in the META-INF/services directory. The file should contain all your implementations of the base interface, each on its own line.","title":"Declaration"},{"location":"plugins/declaration/#declaration","text":"","title":"Declaration"},{"location":"plugins/declaration/#bases","text":"A plugin may implement several base interfaces, which are annotated by @Base , @ActiveBase or @IdBase . Superclasses which are not annotated with either of those are ignored.","title":"Bases"},{"location":"plugins/declaration/#base","text":"Use this to annotate a base class or interface which other plugins might depend on. It is recommended to create a base interface or class for your plugin, even if you don't plan on creating multiple implementations yourself.","title":"@Base"},{"location":"plugins/declaration/#activebase","text":"This annotation marks a base which is either actively used by the bot (like Provider and Suggester ), or actively provides a feature and should be enabled even if no other active plugin depends on it. Plugins implementing an active base must also have an ID base.","title":"@ActiveBase"},{"location":"plugins/declaration/#idbase","text":"If your plugin implements an active base (such as Provider or Suggester ), it needs a base that identifies it. There will always be only one enabled plugin per ID base. For example, a provider of Spotify songs should implement a base interface SpotifyProvider annotated with @IdBase . Songs that implementation provides would not have a reference to the implementation itself, but to its ID, SpotifyProvider . If someone else comes along now and creates an alternative implementation of that ID base, songs created by the first implementation could still be used even though the implementation changed. If, for some reason, you absolutely don't want to create a separate base interface, you may also annotate your implementation with @IdBase directly. A plugin must not have more than one ID base.","title":"@IdBase"},{"location":"plugins/declaration/#examples","text":"","title":"Examples"},{"location":"plugins/declaration/#provider","text":"A Provider for Spotify songs may have a base interface SpotifyProvider , which is declared as an @IdBase . All implementations of the SpotifyProvider base must use the same song ID format to be compatible. @IdBase(\"Spotify\") interface SpotifyProvider : Provider class SpotifyProviderImpl : SpotifyProvider","title":"Provider"},{"location":"plugins/declaration/#playbackfactory","text":"The PlaybackFactory interface does not have value in itself, so instead, just specializations of the PlaybackFactory interface are annotated with @Base , for example Mp3PlaybackFactory or YouTubePlaybackFactory . An implementation using VLC to play a variety of file formats may look like this: interface VlcPlaybackFactory : Mp3PlaybackFactory, AacPlaybackFactory, FlacPlaybackFactory class VlcPlaybackFactoryImpl : VlcPlaybackFactory Note that the base interfaces used here are predefined in the core library. An implementation for Spotify songs may look like this: @Base interface SpotifyPlaybackFactory : PlaybackFactory { fun getPlayback(spotifySongId: String): Playback } class SpotifyPlaybackFactoryImpl : SpotifyPlaybackFactory Note that in this case, the base interface declares the crucial getPlayback(...) method itself. Without it, a PlaybackFactory would not be not useful at all.","title":"PlaybackFactory"},{"location":"plugins/declaration/#service","text":"In order for the bot to find your plugin, you have to create a file with the fully qualified name of the implemented plugin interface (e.g. net.bjoernpetersen.musicbot.spi.plugin.Provider ) in the META-INF/services directory. The file should contain all your implementations of the base interface, each on its own line.","title":"Service"},{"location":"plugins/lifecycle/","text":"Lifecycle \u00b6 Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation. Creation \u00b6 Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, its dependencies are statically evaluated and the only properties that will be accessed are the name and description properties. The end user chooses which plugins to actually activate and how dependencies are satisfied before moving on to the next lifecycle phase. Configuration \u00b6 The plugin's dependencies are injected and its configuration methods are called: createStateEntries(Config) createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities. Initialization \u00b6 The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed. Destruction \u00b6 The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Lifecycle"},{"location":"plugins/lifecycle/#lifecycle","text":"Plugins have a well defined lifecycle, and it is extremely important that you understand it in order to create your own implementation.","title":"Lifecycle"},{"location":"plugins/lifecycle/#creation","text":"Every plugin is instantiated by the bot using a public no-arg constructor. The constructor should do no more than basic object setup, it should especially not bind resources. While the plugin is in this state, its dependencies are statically evaluated and the only properties that will be accessed are the name and description properties. The end user chooses which plugins to actually activate and how dependencies are satisfied before moving on to the next lifecycle phase.","title":"Creation"},{"location":"plugins/lifecycle/#configuration","text":"The plugin's dependencies are injected and its configuration methods are called: createStateEntries(Config) createConfigEntries(Config): List<Config.Entry<*>> createSecretEntries(Config): List<Config.Entry<*>> The three methods receive different Config objects appropriate for the specific kind of data. Only the configuration entries returned by the methods are shown to the user to configure, but you are free to create more. In this state the plugin may temporarily do work if configuration is requested. For example, if a list of choices for a Playlist to play is requested in the config UI, the plugin may connect to a web service and retrieve a list of possibilities.","title":"Configuration"},{"location":"plugins/lifecycle/#initialization","text":"The initialize(InitStateWriter) method is called and the plugin may allocate resources, start long-running jobs etc. The plugin remains in this state until it is explicitly closed.","title":"Initialization"},{"location":"plugins/lifecycle/#destruction","text":"The close() method is called and the plugin must release all resources. The instance will never be reinitialized or used again.","title":"Destruction"},{"location":"plugins/resources/","text":"Resources \u00b6 Provider plugins may allocate resources when a song is loaded via the Provider.loadSong() method. Such a resource could be reusable (e.g. a downloaded file) or single-use (e.g. a data stream). Whenever the Core determines that the resource for a song might be needed soon, it will check whether a valid resource is cached for the song, and if not, call your loadSong() implementation. The resource might be discarded without ever being used, but before a resource is discarded, it is guaranteed that the Resource.free() method will be called. Examples \u00b6 No resources \u00b6 If you don't need to allocate any resources, you can simply return the NoResource singleton. override fun loadSong(song: Song): Resource = NoResource File resources \u00b6 A commonly used type of resource is a file resource. Let's say your provider needs to download an MP3-file before playing it. That MP3-file of course needs to be deleted at some point in the future, because storage space is typically finite. For that use case, the FileResource class is already included in the Core library. In this case your loadSong() and supplyPlayback() methods might look the following way: @Base interface MyPlaybackFactory : FilePlaybackFactory @IdBase class MyProvider : Provider { @Inject private lateinit var myPlaybackFactory: MyPlaybackFactory // ... override fun loadSong(song: Song): Resource { val file: File = downloadSong(song) return FileResource(file) } override fun supplyPlayback(song: Song, resource: Resource): Playback { val fileResource = resource as FileResource return myPlaybackFactory.createPlayback(fileResource.file) } }","title":"Resources"},{"location":"plugins/resources/#resources","text":"Provider plugins may allocate resources when a song is loaded via the Provider.loadSong() method. Such a resource could be reusable (e.g. a downloaded file) or single-use (e.g. a data stream). Whenever the Core determines that the resource for a song might be needed soon, it will check whether a valid resource is cached for the song, and if not, call your loadSong() implementation. The resource might be discarded without ever being used, but before a resource is discarded, it is guaranteed that the Resource.free() method will be called.","title":"Resources"},{"location":"plugins/resources/#examples","text":"","title":"Examples"},{"location":"plugins/resources/#no-resources","text":"If you don't need to allocate any resources, you can simply return the NoResource singleton. override fun loadSong(song: Song): Resource = NoResource","title":"No resources"},{"location":"plugins/resources/#file-resources","text":"A commonly used type of resource is a file resource. Let's say your provider needs to download an MP3-file before playing it. That MP3-file of course needs to be deleted at some point in the future, because storage space is typically finite. For that use case, the FileResource class is already included in the Core library. In this case your loadSong() and supplyPlayback() methods might look the following way: @Base interface MyPlaybackFactory : FilePlaybackFactory @IdBase class MyProvider : Provider { @Inject private lateinit var myPlaybackFactory: MyPlaybackFactory // ... override fun loadSong(song: Song): Resource { val file: File = downloadSong(song) return FileResource(file) } override fun supplyPlayback(song: Song, resource: Resource): Playback { val fileResource = resource as FileResource return myPlaybackFactory.createPlayback(fileResource.file) } }","title":"File resources"}]}